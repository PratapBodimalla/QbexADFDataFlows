{
	"name": "df_functions",
	"properties": {
		"folder": {
			"name": "DataFlowFunctions"
		},
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"linkedService": {
						"referenceName": "ls_blob_qbexblobstoragedemofiles",
						"type": "LinkedServiceReference"
					},
					"name": "source1"
				},
				{
					"dataset": {
						"referenceName": "ds_student_marks_json",
						"type": "DatasetReference"
					},
					"name": "source2"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "ds_adls_folder",
						"type": "DatasetReference"
					},
					"name": "sink1"
				}
			],
			"transformations": [
				{
					"name": "derivedColumn1"
				},
				{
					"name": "filter1"
				},
				{
					"name": "derivedColumn2"
				}
			],
			"scriptLines": [
				"parameters{",
				"     parameter1 as string ('200 + 300'),",
				"     p_StartDate as date (toDate('2024-08-24')),",
				"     p_EndDate as date (toDate('2024-10-04'))",
				"}",
				"source(output(",
				"          school as string,",
				"          class as string,",
				"          {student id} as short,",
				"          student_name as string,",
				"          {subject-1-marks} as short,",
				"          {subject-2-marks} as short,",
				"          {subject-3-marks} as short,",
				"          {subject-4-marks} as short,",
				"          {subject-5-marks} as short,",
				"          {total-marks} as short",
				"     ),",
				"     useSchema: false,",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false,",
				"     format: 'delimited',",
				"     container: 'data',",
				"     folderPath: 'student_marks',",
				"     fileName: 'sample_school_data.csv',",
				"     columnDelimiter: ',',",
				"     escapeChar: '\\\\',",
				"     quoteChar: '\\\"',",
				"     columnNamesAsHeader: true) ~> source1",
				"source(output(",
				"          school as string,",
				"          class as integer,",
				"          {student id} as integer,",
				"          student_name as string,",
				"          Marks as (Languages as (english_marks as integer, telugu_marks as integer), main_subjects as (math_marks as integer, science_marks as integer, social_marks as integer))",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false,",
				"     documentForm: 'documentPerLine') ~> source2",
				"filter1 derive(metadata_functions = /* Metadata functions */\r",
				"\r",
				"/* 1. byName */\r",
				"toString(byName('student_name'))\r",
				"\r",
				"/* 2. byNames */\r",
				"/* toString(byNames(['student_name','school'])) */\r",
				"/* toString(byNames(['school','student_name'])) */\r",
				"\r",
				"/* 3. byOrigin */\r",
				"/* toString(byOrigin('student_name','source1')) */\r",
				"\r",
				"/* 4. byOrigins */\r",
				"/* toString(byOrigins(['student_name','school'],'source1')) */\r",
				"/* toString(byOrigins(['school','student_name'],'source1')) */\r",
				"\r",
				"/* 5. by position */\r",
				"/* toString(byPosition(1)) */\r",
				"/* toString(byPosition(4)) */\r",
				"\r",
				"\r",
				"/* 6. originColumns */\r",
				"/* array(toString(originColumns('source1'))) */,",
				"          expression_functions = /* Expression Functions */\r",
				"/* 1. case */\r",
				"/* case({student id}==1,'yes',{student id}==2,'no','NA') */\r",
				"\r",
				"/* 2. columnNames */\r",
				"/* columnNames('source1') */\r",
				"\r",
				"/* 3. escape */\r",
				"/* escape('{\"key\":\"test\"','json') */\r",
				"\r",
				"/* 4 expr -> Dynamic Expressions  */\r",
				"/* expr($parameter1) */\r",
				"\r",
				"/* 5. hasColumn */\r",
				"/* hasColumn('student_name', 'source1') */\r",
				"\r",
				"/* 6. iif */\r",
				"/* iif({student id}==1,'Yes','No') */\r",
				"\r",
				"/* 7. iifNull same like coaleace*/\r",
				"/* iifNull(null(),10) */\r",
				"\r",
				"/* 8. md5 */\r",
				"/* md5(school,class,{student id},student_name) */\r",
				"\r",
				"/* 9. regex_match */\r",
				"/* regexMatch(student_name, `^A.*`) */\r",
				"/* regexMatch(student_name, `^[A-D].*`) */\r",
				"\r",
				"/* 10. reges_split */\r",
				"/* regexSplit('pratapQqbexBbodimalla', `[QB]`) */\r",
				"\r",
				"/* 11. regexExtract */\r",
				"/* regexExtract('Cost is between 600 and 800 dollars', '(\\\\d+) and (\\\\d+)', 1) */\r",
				"/* regexExtract('Cost is between 600 and 800 dollars', '(\\\\d+) and (\\\\d+)', 2) */\r",
				"\r",
				"/* 12. regex_replace */\r",
				"/* regexReplace('100 and 200', '(\\\\d+)', 'pratap') */\r",
				"\r",
				"/* 13. uuid */\r",
				"uuid(),",
				"          date_time_functions = /* Date Time Functions */\r",
				"/* 1. Get Current Date */\r",
				"/* currentDate() */\r",
				"/* currentDate('EST') */\r",
				"\r",
				"/* 2. Get Current Timestamp */\r",
				"/* currentTimestamp() */\r",
				"\r",
				"/* 3. Get current UTC \r",
				"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html */\r",
				"/* currentUTC() */\r",
				"/* currentUTC('IST') */\r",
				"\r",
				"/* 4. toDate & toTimestamp*/\r",
				"/* toDate('2024-10-02') */\r",
				"/* toDate('2024-02-10','yyyy-dd-MM') */\r",
				"/* toDate('2024-02-8','yyyy-dd-M') */\r",
				"/* toTimestamp('2016-12-31 00:12:00') */\r",
				"/* toTimestamp('12/31/2016T00:12:00', 'MM/dd/yyyy\\'T\\'HH:mm:ss') */\r",
				"/* millisecond(toTimestamp('2019-02-03 05:19:28.871', 'yyyy-MM-dd HH:mm:ss.SSS')) */\r",
				"\r",
				"/* 5. addDays and subDays*/\r",
				"/* addDays(toDate('2016-08-08'), 1) */\r",
				"/* addDays(currentDate(), 1) */\r",
				"/* addDays(currentDate(),-10) */\r",
				"/* subDays(currentDate(),10) */\r",
				"\r",
				"/* 6. addMonths and subMonths*/\r",
				"/* addMonths(currentDate(), 1) */\r",
				"/* subMonths(currentDate(), 1) */\r",
				"\r",
				"/* 7. between */\r",
				"/* between(12,10,20) */\r",
				"/* between(currentDate(), subDays(currentDate(),0),addDays(currentDate(),-10)) */\r",
				"\r",
				"/* 8. dayOfMonth, dayOfWeek, dayOfYear */\r",
				"/* dayOfMonth(currentDate()) */\r",
				"/* dayOfWeek(currentDate()) */\r",
				"/* dayOfYear(currentDate()) */\r",
				"\r",
				"/* 9. Days, hours, minutes, seconds , weeks\r",
				"return number of milliseconds*/\r",
				"/* days(1) */\r",
				"/* hours(1) */\r",
				"/* minutes(1) */\r",
				"/* seconds(1) */\r",
				"/* weeks(1) */\r",
				"\r",
				"\r",
				"/* 10. fromUTC convert UTC to required timezone & toUTC*/\r",
				"/* fromUTC(currentTimestamp(), 'IST') */\r",
				"/* toUTC(currentTimestamp()) */\r",
				"\r",
				"/* 11. hour -> return hour from timestamp */\r",
				"/* hour(fromUTC(currentTimestamp(), 'IST')) */\r",
				"\r",
				"/* 12. isDate \r",
				"[ yyyy, yyyy-[M]M, yyyy-[M]M-[d]d, yyyy-[M]M-[d]dT* ] */\r",
				"/* isDate('2024-10-04') */\r",
				"/* isDate('2024-oct-04') */\r",
				"\r",
				"\r",
				"/* 13. lastDayOfMonth */\r",
				"/* lastDayOfMonth(currentDate()) */\r",
				"\r",
				"\r",
				"/* 14. minus */\r",
				"/* minus(20, 10) */\r",
				"/* 20 - 10 */\r",
				"/* minus(toDate('2012-12-15'), 3) */\r",
				"/* toDate('2012-12-15') - 3  */\r",
				"/* toTimestamp('2019-02-03 05:19:28.871', 'yyyy-MM-dd HH:mm:ss.SSS') + (days(1) + hours(2) - seconds(10))  */\r",
				"/* toTimestamp('2019-02-03 05:21:34.851', 'yyyy-MM-dd HH:mm:ss.SSS') - toTimestamp('2019-02-03 05:21:36.923', 'yyyy-MM-dd HH:mm:ss.SSS') */\r",
				"\r",
				"/* 15. month */\r",
				"/* month(currentDate()) */\r",
				"\r",
				"/* How to get Month Name */\r",
				"\r",
				"/* 16. monthsBetween */\r",
				"/* monthsBetween(currentDate(), addDays(currentDate(),-100), false(), 'UTC') */\r",
				"/* monthsBetween(currentDate(), addDays(currentDate(),-100), true(), 'UTC') */\r",
				"/* monthsBetween(toTimestamp('1997-02-28 10:30:00'), toDate('1996-10-30')) */\r",
				"\r",
				"/* 17. second */\r",
				"/* second(toTimestamp('2009-07-30 12:58:59')) */\r",
				"\r",
				"/* weekOfYear */\r",
				"/* weekOfYear(currentDate()) */\r",
				"\r",
				"\r",
				"/* year */\r",
				"year(currentDate()),",
				"          array_functions = /* Array Functions */\r",
				"/* 1.array */\r",
				"array('Seattle', 'Washington')\r",
				"/* ['Seattle', 'Washington'] */\r",
				"/* ['Seattle', 'Washington'][1] */\r",
				"/* 'Washington' */\r",
				"\r",
				"/* 2.at */\r",
				"/* at(['apples', 'pears'], 1) */\r",
				"/* at(['fruit' -> 'apples', 'vegetable' -> 'carrot'], 'fruit') */\r",
				"\r",
				"/* 3. contains */\r",
				"/* contains([1, 2, 3, 4], #item == 3) */\r",
				"/* contains([1, 2, 3, 4], #item > 5) */\r",
				"\r",
				"/* 4. distinct */\r",
				"/* distinct([10, 20, 30, 10]) */\r",
				"\r",
				"/* 5. except */\r",
				"/* except([10, 20, 30], [20, 40]) */\r",
				"\r",
				"/* 6. filter */\r",
				"/* filter([1, 2, 3, 4], #item > 2) */\r",
				"/* filter(['a', 'b', 'c', 'd'], #item == 'a' || #item == 'b') */\r",
				"\r",
				"/* 7 find */\r",
				"/* find([10, 20, 30], #item > 10) */\r",
				"\r",
				"/* 8. flatten */\r",
				"/* flatten([['bojjus', 'girl'], ['gunchus', 'boy']]) */\r",
				"/* flatten([[['bojjus', 'gunchus']]] , true()) */\r",
				"\r",
				"/* 9. in */\r",
				"/* in([10, 20, 30], 10) */\r",
				"/* in(['good', 'kid'], 'bad') */\r",
				"\r",
				"/* 10. intersect */\r",
				"/* intersect([10, 20, 30], [20, 40]) */\r",
				"\r",
				"/* 11. map */\r",
				"/* map([1, 2, 3, 4], #item + 2) */\r",
				"/* map(['a', 'b', 'c', 'd'], #item + '_processed') */\r",
				"\r",
				"/* 12. mapif */\r",
				"/* mapIf([10, 20, 30], #item > 10, #item + 5) */\r",
				"/* mapIf(['icecream', 'cake', 'soda'], length(#item) > 4, upper(#item)) */\r",
				"\r",
				"/* 13. mapindex */\r",
				"/* mapIndex([1, 2, 3, 4], #item + 2 + #index) */\r",
				"\r",
				"/* 14. maploop */\r",
				"/* mapLoop(3, #index * 10) */\r",
				"\r",
				"/* 15. reduce */\r",
				"/* toString(reduce(['1', '2', '3', '4'], '0', #acc + #item, #result)) */\r",
				"\r",
				"/* 16. size */\r",
				"/* size(['element1', 'element2']) */\r",
				"/* size([1,2,3]) */\r",
				"\r",
				"/* 17. slice */\r",
				"/* slice([10, 20, 30, 40], 1, 2) */\r",
				"/* slice([10, 20, 30, 40], 2) */\r",
				"\r",
				"/* 18. sort */\r",
				"/* sort([4, 8, 2, 3], compare(#item1, #item2)) */\r",
				"/* sort(['a3', 'b2', 'c1'], iif(right(#item1, 1) >= right(#item2, 1), 1, -1)) */\r",
				"\r",
				"/* 19.union */\r",
				"/* union([10, 20, 30], [20, 40]) */\r",
				"\r",
				"/* 20. unfold */\r",
				"/* like unnest */,",
				"          local1 := columns('filter1')) ~> derivedColumn1",
				"source1 filter(school == 'School_A') ~> filter1",
				"source2 derive(meta_data_functions = /* Metadata functions */\r",
				"\r",
				"/* 1. byName */\r",
				"/* toString(byName('student_name')) */\r",
				"\r",
				"/* 2. byNames */\r",
				"/* toString(byNames(['student_name','school'])) */\r",
				"/* toString(byNames(['school','student_name'])) */\r",
				"\r",
				"/* 3. byOrigin */\r",
				"/* toString(byOrigin('student_name','source1')) */\r",
				"\r",
				"/* 4. byOrigins */\r",
				"/* toString(byOrigins(['student_name','school'],'source1')) */\r",
				"/* toString(byOrigins(['school','student_name'],'source1')) */\r",
				"\r",
				"/* 5. by position */\r",
				"/* toString(byPosition(1)) */\r",
				"/* toString(byPosition(4)) */\r",
				"\r",
				"\r",
				"/* 6. originColumns */\r",
				"/* array(toString(originColumns('source1'))) */\r",
				"\r",
				"/* next json relevent */\r",
				"\r",
				"/* 7. hasPath */\r",
				"hasPath('Marks.main_subjects.math_marks')\r",
				"\r",
				"/* 8. byPath */\r",
				"/* toString(byPath('Marks.main_subjects.math_marks')) */) ~> derivedColumn2",
				"derivedColumn1 sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          COUNTRY as string,",
				"          {COUNTRY CODE} as string,",
				"          {ISO CODES} as string,",
				"          POPULATION as string,",
				"          {AREA KM2} as string,",
				"          GDP_USD as string",
				"     ),",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> sink1"
			]
		}
	}
}